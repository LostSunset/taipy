# Â© 2021-2025, Avaiga Pte Ltd. All Rights Reserved. The use of the Taipy software and any part thereof is governed by
# Avaiga Pte Ltd's Software License and Maintenance Agreement. Unauthorised use, reproduction and modification is
# strictly not allowed.

import argparse
import os
import typing as t
from io import StringIO

from taipy.gui.extension import ElementLibrary, PropertyType


def error(message):
    print(message)  # noqa: T201
    exit(1)


def generate_doc(library: ElementLibrary) -> str:  # noqa: C901F
    stream = StringIO()

    def clean_doc_string(doc_string) -> t.Optional[str]:
        if not doc_string:
            return None
        lines = doc_string.splitlines()
        min_indent = min((len(line) - len(line.lstrip())) for line in lines if line.strip())
        lines = [line[min_indent:] if line.strip() else "" for line in lines]
        while lines and not lines[0].strip():
            lines.pop(0)
        while lines and not lines[-1].strip():
            lines.pop()
        return "\n".join(lines) if lines else None

    print("# ----------------------------------------------------------------------", file=stream)
    print("# Generated by taipy.gui.extension module", file=stream)
    print("# ----------------------------------------------------------------------", file=stream)
    for element_name, element in library.get_elements().items():
        properties: list[str] = []
        property_doc = {}
        default_property_found = False
        for property_name, property in element.attributes.items():
            desc = property_name
            # Could use 'match' with Python >= 3.10
            if property.property_type in [PropertyType.boolean, PropertyType.dynamic_boolean]:
                desc = desc + ": bool"
            elif property.property_type in [PropertyType.string, PropertyType.dynamic_string]:
                desc = desc + ": str"
            elif property.property_type in [PropertyType.dict, PropertyType.dynamic_dict]:
                desc = desc + ": dict"
            if property_name == element.default_attribute:
                properties.insert(0, desc)
                default_property_found = True
            else:
                properties.append(desc)
            if doc_string := clean_doc_string(property.doc_string):
                property_doc[property_name] = doc_string
        if default_property_found and len(properties) > 1:
            properties.insert(1, "*")
        doc_string = clean_doc_string(element.doc_string)
        documentation = ""
        if doc_string:
            lines = doc_string.splitlines()
            documentation = f'    """{lines.pop(0)}\n'
            while lines:
                line = lines.pop(0)
                documentation += f"    {line}\n" if line else "\n"
        if property_doc:
            documentation += "\n    Arguments:\n"
            for property_name, doc_string in property_doc.items():
                lines = doc_string.splitlines()
                documentation += f"        {property_name}: {lines.pop(0)}\n"
                while lines:
                    line = lines.pop(0)
                    if line:
                        documentation += f"        {line}\n"
        if documentation:
            documentation += '    """\n'
        print(f"def {element_name}({', '.join(properties)}):\n{documentation}    ...\n\n", file=stream)

    return stream.getvalue()


def generate_tgb(args) -> None:
    from importlib import import_module
    from inspect import getmembers, isclass

    package_root_dir = args.package_root_dir[0]
    # Remove potential directory separator at the end of the package root dir
    if package_root_dir[-1] == "/" or package_root_dir[-1] == "\\":
        package_root_dir = package_root_dir[:-1]
    module = None
    try:
        module = import_module(package_root_dir)
    except Exception as e:
        error(f"Couldn't open module '{package_root_dir}' ({e})")
    library: t.Optional[ElementLibrary] = None
    for _, member in getmembers(module, lambda o: isclass(o) and issubclass(o, ElementLibrary)):
        if library:
            error("Extension contains more than one ElementLibrary")
        library = member()
    if library is None:
        error("Extension does not contain any ElementLibrary")
        return  # To avoid having to deal with this case in the following code
    pyi_path = os.path.join(package_root_dir, "__init__.pyi")
    pyi_file = None
    try:
        pyi_file = open(pyi_path, "w")
    except Exception as e:
        error(f"Couldn't open Python Interface Definition file '{pyi_file}' ({e})")

    print(f"Inspecting extension library '{library.get_name()}'")  # noqa: T201
    content = generate_doc(library)

    if pyi_file:
        print(content, file=pyi_file)
        pyi_file.close()
    print(f"File '{pyi_path}' was updated.")  # noqa: T201


def main(arg_strings=None) -> None:
    parser = argparse.ArgumentParser(description="taipy.gui.extensions entry point.")
    sub_parser = parser.add_subparsers(dest="command", help="Commands to run", required=True)

    tgb_generation = sub_parser.add_parser(
        "generate_tgb", aliases=["api"], help="Generate Page Builder API for a Taipy GUI extension package."
    )
    tgb_generation.add_argument(
        dest="package_root_dir",
        nargs=1,
        help="The root dir of the extension package." + " This directory must contain a __init__.py file.",
    )
    tgb_generation.set_defaults(func=generate_tgb)

    args = parser.parse_args(arg_strings)
    args.func(args)


if __name__ == "__main__":
    main()
